.TH "src/exec/exec.h" 3 "Sat May 30 2020" "Version v0.1" "42h" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/exec/exec.h \- Execution functions\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <unistd\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <err\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <sys/wait\&.h>\fP
.br
\fC#include '\&.\&./parser/parser\&.h'\fP
.br
\fC#include '\&.\&./exec/commands\&.h'\fP
.br
\fC#include '\&.\&./utils/buffer\&.h'\fP
.br
\fC#include '\&.\&./utils/string_utils\&.h'\fP
.br
\fC#include '\&.\&./utils/my_itoa\&.h'\fP
.br
\fC#include '\&.\&./utils/xalloc\&.h'\fP
.br
\fC#include '\&.\&./storage/var_storage\&.h'\fP
.br
\fC#include '\&.\&./exec/redirection\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBcommands\fP"
.br
.ti -1c
.RI "struct \fBcommand_continue\fP"
.br
.ti -1c
.RI "struct \fBcommand_break\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBNB_MAX_PIPE\fP   10"
.br
.ti -1c
.RI "#define \fBERROR\fP(msg)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBinit_continue\fP (void)"
.br
.ti -1c
.RI "void \fBinit_break\fP (void)"
.br
.ti -1c
.RI "bool \fBexec_node_input\fP (struct \fBnode_input\fP *ast)"
.br
.RI "execute input "
.ti -1c
.RI "bool \fBexec_node_list\fP (struct \fBnode_list\fP *ast)"
.br
.RI "execute list "
.ti -1c
.RI "bool \fBexec_node_and_or\fP (struct \fBnode_and_or\fP *ast)"
.br
.RI "execute and/or "
.ti -1c
.RI "bool \fBexec_node_pipeline\fP (struct \fBnode_pipeline\fP *ast)"
.br
.RI "execute pipeline "
.ti -1c
.RI "bool \fBexec_node_command\fP (struct \fBnode_command\fP *ast, bool with_fork)"
.br
.RI "execute command "
.ti -1c
.RI "bool \fBexec_node_simple_command\fP (struct \fBnode_simple_command\fP *ast, bool with_fork)"
.br
.RI "execute simple command "
.ti -1c
.RI "bool \fBexec_node_shell_command\fP (struct \fBnode_shell_command\fP *ast)"
.br
.RI "execute shell command "
.ti -1c
.RI "bool \fBexec_node_funcdec\fP (struct \fBnode_funcdec\fP *ast)"
.br
.RI "execute funcdec "
.ti -1c
.RI "bool \fBexec_node_redirection\fP (struct \fBnode_redirection\fP *ast)"
.br
.RI "execute redirection "
.ti -1c
.RI "bool \fBexec_node_prefix\fP (struct \fBnode_prefix\fP *ast)"
.br
.RI "execute prefix "
.ti -1c
.RI "bool \fBexec_node_element\fP (struct \fBnode_element\fP *ast)"
.br
.RI "execute element "
.ti -1c
.RI "bool \fBexec_node_compound_list\fP (struct \fBnode_compound_list\fP *ast)"
.br
.RI "execute compound list "
.ti -1c
.RI "bool \fBexec_node_while\fP (struct \fBnode_while\fP *ast)"
.br
.RI "execute while "
.ti -1c
.RI "bool \fBexec_node_until\fP (struct \fBnode_until\fP *ast)"
.br
.RI "execute until "
.ti -1c
.RI "bool \fBexec_node_case\fP (struct \fBnode_case\fP *ast)"
.br
.RI "execute case "
.ti -1c
.RI "bool \fBexec_node_if\fP (struct \fBnode_if\fP *ast)"
.br
.RI "execute if "
.ti -1c
.RI "bool \fBexec_node_elif\fP (struct \fBnode_if\fP *ast)"
.br
.RI "execute elif "
.ti -1c
.RI "bool \fBexec_node_for\fP (struct \fBnode_for\fP *ast)"
.br
.RI "execute for "
.ti -1c
.RI "bool \fBexec_node_else_clause\fP (struct \fBnode_else_clause\fP *ast)"
.br
.RI "execute else clause "
.ti -1c
.RI "bool \fBexec_node_do_group\fP (struct \fBnode_do_group\fP *ast)"
.br
.RI "execute do group "
.ti -1c
.RI "bool \fBexec_node_case_clause\fP (struct \fBnode_case_clause\fP *ast, char *word_to_found)"
.br
.RI "execute case clause "
.ti -1c
.RI "bool \fBexec_node_case_item\fP (struct \fBnode_case_item\fP *ast, char *word_to_found)"
.br
.RI "execute case item "
.ti -1c
.RI "int \fBperform_for_range\fP (struct \fBrange\fP *r, struct \fBnode_for\fP *ast)"
.br
.RI "for function to execute different range "
.ti -1c
.RI "bool \fBperform_for_enumeration\fP (struct \fBnode_for\fP *ast, int len_range)"
.br
.RI "for function to perform enumeration "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "struct \fBcommand_continue\fP \fBcont\fP"
.br
.ti -1c
.RI "struct \fBcommand_break\fP \fBbr\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Execution functions\&. 


.PP
\fBAuthor\fP
.RS 4
Team 
.RE
.PP
\fBVersion\fP
.RS 4
0\&.1 
.RE
.PP
\fBDate\fP
.RS 4
2020-05-03
.RE
.PP
\fBCopyright\fP
.RS 4
Copyright (c) 2020 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define ERROR(msg)"
\fBValue:\fP
.PP
.nf
            fprintf(stderr, "%s\n", msg); \
            return true; \
.fi
.SS "#define NB_MAX_PIPE   10"

.SH "Function Documentation"
.PP 
.SS "bool exec_node_and_or (struct \fBnode_and_or\fP * ast)"

.PP
execute and/or 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_case (struct \fBnode_case\fP * ast)"

.PP
execute case 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_case_clause (struct \fBnode_case_clause\fP * ast, char * word_to_found)"

.PP
execute case clause 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_case_item (struct \fBnode_case_item\fP * ast, char * word_to_found)"

.PP
execute case item 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_command (struct \fBnode_command\fP * ast, bool with_fork)"

.PP
execute command 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.br
\fIwith_fork\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_compound_list (struct \fBnode_compound_list\fP * ast)"

.PP
execute compound list 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_do_group (struct \fBnode_do_group\fP * ast)"

.PP
execute do group 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_element (struct \fBnode_element\fP * ast)"

.PP
execute element 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_elif (struct \fBnode_if\fP * ast)"

.PP
execute elif 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_else_clause (struct \fBnode_else_clause\fP * ast)"

.PP
execute else clause 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_for (struct \fBnode_for\fP * ast)"

.PP
execute for 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_funcdec (struct \fBnode_funcdec\fP * ast)"

.PP
execute funcdec 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_if (struct \fBnode_if\fP * ast)"

.PP
execute if 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_input (struct \fBnode_input\fP * ast)"

.PP
execute input 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_list (struct \fBnode_list\fP * ast)"

.PP
execute list 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_pipeline (struct \fBnode_pipeline\fP * ast)"

.PP
execute pipeline 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_prefix (struct \fBnode_prefix\fP * ast)"

.PP
execute prefix 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_redirection (struct \fBnode_redirection\fP * ast)"

.PP
execute redirection 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_shell_command (struct \fBnode_shell_command\fP * ast)"

.PP
execute shell command 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_simple_command (struct \fBnode_simple_command\fP * ast, bool with_fork)"

.PP
execute simple command 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.br
\fIwith_fork\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_until (struct \fBnode_until\fP * ast)"

.PP
execute until 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "bool exec_node_while (struct \fBnode_while\fP * ast)"

.PP
execute while 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "void init_break (void)"
Global for continue command 
.SS "void init_continue (void)"
Global for continue command 
.SS "bool perform_for_enumeration (struct \fBnode_for\fP * ast, int len_range)"

.PP
for function to perform enumeration 
.PP
\fBParameters\fP
.RS 4
\fIast\fP 
.br
\fIlen_range\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "int perform_for_range (struct \fBrange\fP * r, struct \fBnode_for\fP * ast)"

.PP
for function to execute different range 
.PP
\fBParameters\fP
.RS 4
\fIr\fP 
.br
\fIast\fP 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "struct \fBcommand_break\fP br"

.SS "struct \fBcommand_continue\fP cont"

.SH "Author"
.PP 
Generated automatically by Doxygen for 42h from the source code\&.
