.TH "src/lexer/lexer.c" 3 "Sat May 30 2020" "Version v0.1" "42h" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/lexer/lexer.c
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include '\&.\&./utils/xalloc\&.h'\fP
.br
\fC#include '\&.\&./utils/string_utils\&.h'\fP
.br
\fC#include '\&.\&./utils/buffer\&.h'\fP
.br
\fC#include '\&.\&./lexer/token\&.h'\fP
.br
\fC#include '\&.\&./lexer/lexer\&.h'\fP
.br
\fC#include '\&.\&./lexer/lex_evaluation\&.h'\fP
.br
\fC#include '\&.\&./utils/index_utils\&.h'\fP
.br
\fC#include '\&.\&./utils/bracket_counter\&.h'\fP
.br
\fC#include '\&.\&./storage/program_data_storage\&.h'\fP
.br
\fC#include '\&.\&./storage/var_storage\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "char ** \fBsplit\fP (char *\fBstr\fP)"
.br
.ti -1c
.RI "int \fBlex_parenthesis\fP (struct \fBlexer\fP *\fBlexer\fP, struct \fBbuffer\fP *\fBbuffer\fP, char *c, size_t *j)"
.br
.ti -1c
.RI "struct \fBtoken\fP * \fBlex_assignment_word\fP (char *c, size_t *i)"
.br
.RI "process assignment word into token "
.ti -1c
.RI "int \fBlex_separator\fP (struct \fBlexer\fP *\fBlexer\fP, struct \fBbuffer\fP *\fBbuffer\fP, char *c, size_t *j)"
.br
.ti -1c
.RI "int \fBlex_multi_token\fP (struct \fBlexer\fP *\fBlexer\fP, struct \fBbuffer\fP *\fBbuffer\fP, char **splitted, int *i, size_t *j)"
.br
.ti -1c
.RI "int \fBlex_part\fP (struct \fBlexer\fP *\fBlexer\fP, struct \fBbuffer\fP *\fBbuffer\fP, char *c, size_t *j)"
.br
.ti -1c
.RI "int \fBlex_backslash\fP (struct \fBbuffer\fP *\fBbuffer\fP, char *c, size_t *j)"
.br
.ti -1c
.RI "void \fBsubstitute_alias\fP (struct \fBlexer\fP *\fBlexer\fP)"
.br
.ti -1c
.RI "bool \fBinit_lexer\fP (struct \fBlexer\fP *\fBlexer\fP)"
.br
.RI "Fill the token list by creating all the tokens from the given string\&. "
.ti -1c
.RI "struct \fBlexer\fP * \fBnew_lexer\fP (char *\fBstr\fP)"
.br
.RI "Allocate and init a new lexer\&. "
.ti -1c
.RI "struct \fBtoken\fP * \fBpeek\fP (struct \fBlexer\fP *\fBlexer\fP)"
.br
.RI "Return the next token without consume it\&. "
.ti -1c
.RI "struct \fBtoken\fP * \fBpop\fP (struct \fBlexer\fP *\fBlexer\fP)"
.br
.RI "Return and consume the next token from the input stream\&. "
.ti -1c
.RI "void \fBappend\fP (struct \fBlexer\fP *\fBlexer\fP, struct \fBtoken\fP *\fBtoken\fP)"
.br
.RI "Append a new token to the \fBtoken_list\fP of the lexer\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "bool \fBis_word\fP = false"
.br
.ti -1c
.RI "bool \fBis_kw_in\fP = false"
.br
.ti -1c
.RI "bool \fBis_ass_w\fP = false"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void append (struct \fBlexer\fP * lexer, struct \fBtoken\fP * token)"

.PP
Append a new token to the \fBtoken_list\fP of the lexer\&. 
.PP
\fBParameters\fP
.RS 4
\fIlexer\fP the lexer\&. 
.br
\fItoken\fP the token to append\&. 
.RE
.PP

.SS "bool init_lexer (struct \fBlexer\fP * lexer)"

.PP
Fill the token list by creating all the tokens from the given string\&. 
.PP
\fBParameters\fP
.RS 4
\fIlexer\fP the lexer\&. 
.RE
.PP

.SS "struct \fBtoken\fP* lex_assignment_word (char * c, size_t * i)"

.PP
process assignment word into token 
.PP
\fBParameters\fP
.RS 4
\fIc\fP 
.br
\fIi\fP 
.RE
.PP
\fBReturns\fP
.RS 4
struct token* 
.RE
.PP

.SS "int lex_backslash (struct \fBbuffer\fP * buffer, char * c, size_t * j)"

.SS "int lex_multi_token (struct \fBlexer\fP * lexer, struct \fBbuffer\fP * buffer, char ** splitted, int * i, size_t * j)"

.SS "int lex_parenthesis (struct \fBlexer\fP * lexer, struct \fBbuffer\fP * buffer, char * c, size_t * j)"

.SS "int lex_part (struct \fBlexer\fP * lexer, struct \fBbuffer\fP * buffer, char * c, size_t * j)"

.SS "int lex_separator (struct \fBlexer\fP * lexer, struct \fBbuffer\fP * buffer, char * c, size_t * j)"

.SS "struct \fBlexer\fP* new_lexer (char * str)"

.PP
Allocate and init a new lexer\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP the string to use as input stream\&. 
.RE
.PP

.SS "struct \fBtoken\fP* peek (struct \fBlexer\fP * lexer)"

.PP
Return the next token without consume it\&. 
.PP
\fBReturns\fP
.RS 4
the next token from the input stream 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlexer\fP the lexer to lex from 
.RE
.PP

.SS "struct \fBtoken\fP* pop (struct \fBlexer\fP * lexer)"

.PP
Return and consume the next token from the input stream\&. 
.PP
\fBReturns\fP
.RS 4
the next token from the input stream 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlexer\fP the lexer to lex from 
.RE
.PP

.SS "char** split (char * str)"

.SS "void substitute_alias (struct \fBlexer\fP * lexer)"

.SH "Variable Documentation"
.PP 
.SS "bool is_ass_w = false"

.SS "bool is_kw_in = false"

.SS "bool is_word = false"

.SH "Author"
.PP 
Generated automatically by Doxygen for 42h from the source code\&.
